{"version":3,"sources":["src/index.ts"],"names":[],"mappings":"AAKA,OAAO,KAAK,iBAAiB,MAAM,sBAAsB,CAAC;AAC1D,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAQ9C,OAAO,EAAE,iBAAiB,EAAE,aAAa,EAAE,YAAY,EAAE,CAAC;AAE1D;;;;;;;GAOG;AACH,wBAAsB,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,aAAa,GAAG,OAAO,CAAC,YAAY,CAAC,CA4BzF","file":"index.d.ts","sourcesContent":["'use strict';\n\nimport { launch, LaunchedChrome } from 'chrome-launcher';\nimport * as CDP from 'chrome-remote-interface';\n\nimport * as CompletionTrigger from './CompletionTriggers';\nimport { CreateOptions } from './CreateOptions';\nimport { CreateResult } from './CreateResult';\n\nconst DEFAULT_CHROME_FLAGS = [\n  '--disable-gpu',\n  '--headless',\n  '--hide-scrollbars',\n];\n\nexport { CompletionTrigger, CreateOptions, CreateResult };\n\n/**\n * Generates a PDF from the given HTML string, launching Chrome as necessary.\n *\n * @export\n * @param {string} html the HTML string.\n * @param {Options} [options] the generation options.\n * @returns {Promise<CreateResult>} the generated PDF data.\n */\nexport async function create(html: string, options?: CreateOptions): Promise<CreateResult> {\n  const myOptions = Object.assign({}, options);\n  let chrome: LaunchedChrome;\n\n  myOptions._canceled = false;\n  if (myOptions.timeout != null && myOptions.timeout >= 0) {\n    setTimeout(() => {\n      myOptions._canceled = true;\n    }, myOptions.timeout);\n  }\n\n  await throwIfCanceledOrFailed(myOptions);\n  if (!myOptions.host && !myOptions.port) {\n    chrome = await launchChrome(myOptions);\n  }\n\n  try {\n    const tab = await CDP.New(myOptions);\n    try {\n      return await generate(html, myOptions, tab);\n    } finally {\n      await CDP.Close({ ...myOptions, id: tab.id });\n    }\n  } finally {\n    if (chrome) {\n      await chrome.kill();\n    }\n  }\n}\n\n/**\n * Connects to Chrome and generates a PDF from HTML or a URL.\n *\n * @param {string} html the HTML string or URL.\n * @param {CreateOptions} options the generation options.\n * @param {any} tab the tab to use.\n * @returns {Promise<CreateResult>} the generated PDF data.\n */\nasync function generate(html: string, options: CreateOptions, tab: any): Promise<CreateResult>  {\n  await throwIfCanceledOrFailed(options);\n  const client = await CDP({ ...options, target: tab });\n  try {\n    await beforeNavigate(options, client);\n    const {Page} = client;\n    if (/^(https?|file|data):/i.test(html)) {\n      await Promise.all([\n        Page.navigate({url: html}),\n        Page.loadEventFired(),\n      ]); // Resolve order varies\n    } else {\n      const {frameTree} = await Page.getResourceTree();\n      await Promise.all([\n        Page.setDocumentContent({html, frameId: frameTree.frame.id}),\n        Page.loadEventFired(),\n      ]); // Resolve order varies\n    }\n    await afterNavigate(options, client);\n    // https://chromedevtools.github.io/debugger-protocol-viewer/tot/Page/#method-printToPDF\n    const pdf = await Page.printToPDF(options.printOptions);\n    await throwIfCanceledOrFailed(options);\n    return new CreateResult(pdf.data);\n  } finally {\n    client.close();\n  }\n}\n\n/**\n * Code to execute before the page navigation.\n *\n * @param {CreateOptions} options the generation options.\n * @param {*} client the Chrome client.\n * @returns {Promise<void>} resolves if there we no errors or cancellations.\n */\nasync function beforeNavigate(options: CreateOptions, client: any): Promise<void> {\n  const {Network, Page, Runtime} = client;\n  await throwIfCanceledOrFailed(options);\n  if (options.clearCache) {\n    await Network.clearBrowserCache();\n  }\n  // Enable events to be used here, in generate(), or in afterNavigate().\n  await Promise.all([\n    Network.enable(),\n    Page.enable(),\n    Runtime.enable(),\n  ]);\n  if (options.runtimeConsoleHandler) {\n    Runtime.consoleAPICalled(options.runtimeConsoleHandler);\n  }\n  if (options.runtimeExceptionHandler) {\n    Runtime.exceptionThrown(options.runtimeExceptionHandler);\n  }\n  Network.requestWillBeSent((e) => {\n    options._mainRequestId = options._mainRequestId || e.requestId;\n  });\n  Network.loadingFailed((e) => {\n    if (e.requestId === options._mainRequestId) {\n      options._navigateFailed = true;\n    }\n  });\n  if (options.extraHTTPHeaders) {\n    Network.setExtraHTTPHeaders({headers: options.extraHTTPHeaders});\n  }\n  if (options.cookies) {\n    await throwIfCanceledOrFailed(options);\n    await Network.setCookies({cookies: options.cookies});\n  }\n  await throwIfCanceledOrFailed(options);\n}\n\n/**\n * Code to execute after the page navigation.\n *\n * @param {CreateOptions} options the generation options.\n * @param {*} client the Chrome client.\n * @returns {Promise<void>} resolves if there we no errors or cancellations.\n */\nasync function afterNavigate(options: CreateOptions, client: any): Promise<void> {\n  if (options.completionTrigger) {\n    await throwIfCanceledOrFailed(options);\n    const waitResult = await options.completionTrigger.wait(client);\n    if (waitResult && waitResult.exceptionDetails) {\n      await throwIfCanceledOrFailed(options);\n      throw new Error(waitResult.result.value);\n    }\n  }\n  await throwIfCanceledOrFailed(options);\n}\n\n/**\n * Throws an exception if the operation has been canceled or the main page\n * navigation failed.\n *\n * @param {CreateOptions} options the options which track cancellation and failure.\n * @returns {Promise<void>} rejects if canceled or failed, resolves if not.\n */\nasync function throwIfCanceledOrFailed(options: CreateOptions): Promise<void> {\n  if (options._canceled) {\n    throw new Error('HtmlPdf.create() timed out.');\n  }\n  if (options._navigateFailed) {\n    throw new Error('HtmlPdf.create() page navigate failed.');\n  }\n}\n\n/**\n * Launches Chrome with the specified options.\n *\n * @param {CreateOptions} options the options for Chrome.\n * @returns {Promise<LaunchedChrome>} The launched Chrome instance.\n */\nasync function launchChrome(options: CreateOptions): Promise<LaunchedChrome> {\n  const chrome = await launch({\n    port: options.port,\n    chromePath: options.chromePath,\n    chromeFlags: options.chromeFlags || DEFAULT_CHROME_FLAGS,\n  });\n  options.port = chrome.port;\n  return chrome;\n}\n"],"sourceRoot":"../.."}